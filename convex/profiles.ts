import { v } from "convex/values";
import { mutation, query, action } from "./_generated/server";
import { throwIfNotAuthorized } from "./utils";
import { api } from "./_generated/api";

export const createJobSeekerProfile = mutation({
  args: {
    userId: v.id("users"),
    storageId: v.id("_storage"), // Keep storageId for potential future reference, but it won't trigger action here
    title: v.string(),
    summary: v.string(),
    fileUrl:v.string(),
    resumeText: v.string(),
    extractedSkills: v.array(v.string()),
    attitudeQuizResults: v.object({
      workStyle: v.string(),
      problemSolving: v.string(),
      teamDynamics: v.string(),
      workEnvironment: v.string(), // Ensure workEnvironment is included
    }),
  },
  async handler(ctx, args) {
    const user = await ctx.db.get(args.userId);
    if (!user) throw new Error("User not found");

    throwIfNotAuthorized(user.role === "job-seeker", "Only job seekers can create profiles");

    const existingProfile = await ctx.db
      .query("jobSeekerProfiles")
      .withIndex("by_userId", (q) => q.eq("userId", user._id))
      .first();

    if (existingProfile) {
      throw new Error("Profile already exists");
    }

    const profileId = await ctx.db.insert("jobSeekerProfiles", {
      userId: user._id,
      title: args.title,
      summary: args.summary,
      resumeText: args.resumeText, // Insert resumeText directly from args
      extractedSkills: args.extractedSkills, // Insert extractedSkills directly from args
      attitudeQuizResults: args.attitudeQuizResults, // Insert attitudeQuizResults (now includes workEnvironment)
      attitudeTags: [], // Still initialize empty, could be processed by LLM later
      resumeEmbedding: [], // Will be generated by a separate action called from frontend
      fileUrl:await ctx.storage.getUrl(args.storageId)??args.fileUrl,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    });

    // Removed ctx.scheduler.runAfter(0, api.profiles.processResumeAction, { ... });

    return profileId;
  },
});

export const createRecruiterProfile = mutation({
  args: {
    userId: v.id("users"), // Add userId parameter
    companyName: v.string(),
    companySize: v.string(),
    industry: v.string(),
    companyDescription: v.string(),
    attitudePreferences: v.array(v.string()),
  },
  async handler(ctx, args) {
    // Get user directly by ID instead of using ctx.auth
    const user = await ctx.db.get(args.userId);
    if (!user) throw new Error("User not found");

    throwIfNotAuthorized(user?.role === "recruiter", "Only recruiters can create company profiles");

    // Check if profile already exists
    const existingProfile = await ctx.db
      .query("recruiterProfiles")
      .withIndex("by_userId", (q) => q.eq("userId", user._id))
      .first();

    if (existingProfile) {
      throw new Error("Profile already exists");
    }

    const profileId = await ctx.db.insert("recruiterProfiles", {
      userId: user._id,
      companyName: args.companyName,
      companySize: args.companySize,
      industry: args.industry,
      companyDescription: args.companyDescription,
      attitudePreferences: args.attitudePreferences,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    });

    return profileId;
  },
});

export const updateJobSeekerProfile = mutation({
  args: {
    userId: v.id("users"), // Add userId parameter
    title: v.optional(v.string()),
    summary: v.optional(v.string()),
    resumeText: v.optional(v.string()),
    extractedSkills: v.optional(v.array(v.string())),
    attitudeQuizResults: v.optional(v.object({
      workStyle: v.string(),
      problemSolving: v.string(),
      teamDynamics: v.string(),
      workEnvironment: v.string(), // Ensure workEnvironment is here too
    })),
  },
  async handler(ctx, args) {
    const user = await ctx.db.get(args.userId);
    if (!user) throw new Error("User not found");

    throwIfNotAuthorized(user?.role === "job-seeker", "Only job seekers can update their profiles");

    const profile = await ctx.db
      .query("jobSeekerProfiles")
      .withIndex("by_userId", (q) => q.eq("userId", user._id))
      .first();

    if (!profile) {
      throw new Error("Profile not found");
    }

    const updateData: any = { updatedAt: Date.now() };
    if (args.title !== undefined) updateData.title = args.title;
    if (args.summary !== undefined) updateData.summary = args.summary;
    if (args.resumeText !== undefined) updateData.resumeText = args.resumeText;
    if (args.extractedSkills !== undefined) updateData.extractedSkills = args.extractedSkills;
    if (args.attitudeQuizResults !== undefined) updateData.attitudeQuizResults = args.attitudeQuizResults;

    await ctx.db.patch(profile._id, updateData);
  },
});

// Keep existing query functions unchanged
export const getJobSeekerProfile = query({
  args: { userId: v.id("users") },
  async handler(ctx, args) {
    return await ctx.db
      .query("jobSeekerProfiles")
      .withIndex("by_userId", (q) => q.eq("userId", args.userId))
      .first();
  },
});

export const getRecruiterProfile = query({
  args: { userId: v.id("users") },
  async handler(ctx, args) {
    return await ctx.db
      .query("recruiterProfiles")
      .withIndex("by_userId", (q) => q.eq("userId", args.userId))
      .first();
  },
});

// New helper mutation to patch job seeker profile from action
export const patchJobSeekerProfile = mutation({
  args: {
    profileId: v.id("jobSeekerProfiles"),
    updates: v.object({
      resumeText: v.optional(v.string()),
      extractedSkills: v.optional(v.array(v.string())),
      attitudeTags: v.optional(v.array(v.string())),
      resumeEmbedding: v.optional(v.array(v.float64())),
      updatedAt: v.optional(v.float64()),
       // Add other updateable fields here if needed
    }),
  },
  handler: async (ctx, args) => {
    // Note: Authorization checks should ideally happen before calling this mutation
    // if sensitive data is being updated based on external input.
    await ctx.db.patch(args.profileId, args.updates);
  },
});

// Add the new action definition (placeholder)
export const processResumeAction = action({
  args: {
    userId: v.id("users"),
    storageId: v.id("_storage"),
    profileId: v.id("jobSeekerProfiles"),
    attitudeQuizResults: v.object({
      workStyle: v.string(),
      problemSolving: v.string(),
      teamDynamics: v.string(),
      workEnvironment: v.string(),
    }),
  },
  handler: async (ctx, args) => {
    console.log("processResumeAction triggered for profile:", args.profileId);

    try {
      // 1. Get the file URL from storageId
      const fileUrl = await ctx.storage.getUrl(args.storageId);
      if (!fileUrl) {
        console.error("Could not get file URL for storageId:", args.storageId);
        return;
      }
      console.log("Fetched file URL:", fileUrl);

      // 2. Fetch the file content
      // NOTE: Direct PDF parsing in a standard Convex action is complex.
      // This is a placeholder. A robust solution might involve:
      // - Using a dedicated PDF text extraction service (e.g., Cloud Function, external API).
      // - Using an edge function if the PDF is simple text or can be parsed quickly.
      // For now, we'll simulate getting text content.
      let resumeTextContent = "";
      try {
         const response = await fetch(fileUrl);
         if (!response.ok) {
             throw new Error(`Failed to fetch PDF: ${response.statusText}`);
         }
        //  const blob = await response.blob();
         // TODO: Implement actual PDF text extraction from blob
         // This might involve a helper function or external library/service
         resumeTextContent = "[Extracted Resume Text Placeholder]"; // Replace with actual extracted text
         console.log("Simulated resume text extraction");

      } catch (fetchError) {
          console.error("Error fetching or simulating PDF text extraction:", fetchError);
          // Patch profile to indicate processing failed using the helper mutation
           await ctx.runMutation(api.profiles.patchJobSeekerProfile, { 
             profileId: args.profileId, 
             updates: {
               resumeText: "Error processing resume.",
               updatedAt: Date.now(), 
             }
           });
          return; // Stop processing if text extraction fails
      }


      // 3. Use an LLM (like Gemini) to process text and quiz results
      // NOTE: Replace with your actual LLM API call structure and API key management.
      let extractedSkills: string[] = [];
      let attitudeTags: string[] = [];
      const processedResumeText = resumeTextContent; // Use the extracted text
      const quizResults = args.attitudeQuizResults;

      try {
        // Example LLM API call structure (replace with your specific implementation)
        // Requires setting up environment variables for API keys (e.g., process.env.GEMINI_API_KEY)
        const llmResponse = await fetch("YOUR_LLM_API_ENDPOINT", {
           method: "POST",
           headers: { "Content-Type": "application/json" },
           body: JSON.stringify({
             prompt: `Analyze the following resume text and attitude quiz results. Extract key skills and generate attitude tags.\n\nResume Text: ${processedResumeText}\n\nAttitude Quiz Results:\nWork Style: ${quizResults.workStyle}\nProblem Solving: ${quizResults.problemSolving}\nTeam Dynamics: ${quizResults.teamDynamics}\nWork Environment: ${quizResults.workEnvironment}\n\nFormat the output as a JSON object with 'skills' (array of strings) and 'attitudeTags' (array of strings).`,
             // ... other LLM parameters (model, temperature, etc.)
           }),
        });

        if (!llmResponse.ok) {
            throw new Error(`LLM API call failed: ${llmResponse.statusText}`);
        }

        // Placeholder for parsing the LLM response
        const llmData = await llmResponse.json();
        extractedSkills = llmData.skills || []; // Assume LLM returns { skills: [...], attitudeTags: [...] }
        attitudeTags = llmData.attitudeTags || [];
        console.log("Simulated LLM data extraction:", { extractedSkills, attitudeTags });

      } catch (llmError) {
          console.error("Error during LLM API call or parsing:", llmError);
          // Patch profile to indicate partial processing or LLM failure using the helper mutation
           await ctx.runMutation(api.profiles.patchJobSeekerProfile, { 
             profileId: args.profileId,
             updates: { 
               resumeText: processedResumeText, // Save extracted text even if LLM fails
               extractedSkills: [], // Clear skills if LLM failed to extract
               attitudeTags: [], // Clear tags if LLM failed to extract
               updatedAt: Date.now(), 
             }
           });
          return; // Stop if LLM call fails
      }

      // 4. Patch the job seeker profile with the extracted data using the helper mutation
      await ctx.runMutation(api.profiles.patchJobSeekerProfile, { 
        profileId: args.profileId, 
        updates: {
          resumeText: processedResumeText, // Save the extracted text
          extractedSkills: extractedSkills,
          attitudeTags: attitudeTags,
          // resumeEmbedding: [], // Embedding generation would be another step/action
          updatedAt: Date.now(),
        }
      });
      console.log("Job seeker profile patched successfully with extracted data.");

    } catch (generalError) {
      console.error("An unexpected error occurred during resume processing:", generalError);
       // Final fallback patch to indicate overall failure using the helper mutation
       await ctx.runMutation(api.profiles.patchJobSeekerProfile, { 
         profileId: args.profileId,
         updates: { 
           resumeText: "An error occurred during processing.",
           extractedSkills: [],
           attitudeTags: [],
           updatedAt: Date.now(), 
         }
       });
    }

  },
});