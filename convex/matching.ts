import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { throwIfNotAuthorized } from "./utils";

export const createSwipe = mutation({
  args: {
    targetId: v.union(v.id("jobPosts"), v.id("jobSeekerProfiles")),
    direction: v.union(v.literal("left"), v.literal("right")),
    type: v.union(v.literal("job"), v.literal("candidate")),
  },
  async handler(ctx, args) {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthenticated");

    const user = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", identity.email))
      .first();

    if (!user) throw new Error("User not found");

    // Check if swipe already exists
    const existingSwipe = await ctx.db
      .query("swipes")
      .withIndex("by_userId_and_targetId", (q) =>
        q.eq("userId", user._id).eq("targetId", args.targetId)
      )
      .first();

    if (existingSwipe) {
      throw new Error("Already swiped on this target");
    }

    const swipeId = await ctx.db.insert("swipes", {
      userId: user._id,
      targetId: args.targetId,
      direction: args.direction,
      type: args.type,
      createdAt: Date.now(),
    });

    // If right swipe, check for match
    if (args.direction === "right") {
      if (args.type === "job") {
        const jobPost = await ctx.db.get(args.targetId);
        if (!jobPost) throw new Error("Job post not found");

        // Check if recruiter has already swiped right on this job seeker
        const recruiterSwipe = await ctx.db
          .query("swipes")
          .withIndex("by_userId_and_targetId", (q) =>
            q.eq("userId", jobPost.recruiterId).eq("targetId", user._id)
          )
          .first();

        if (recruiterSwipe?.direction === "right") {
          // Create match
          await ctx.db.insert("matches", {
            jobSeekerId: user._id,
            recruiterId: jobPost.recruiterId,
            jobPostId: args.targetId,
            matchReport: "", // Will be generated by AI
            status: "new",
            createdAt: Date.now(),
            updatedAt: Date.now(),
          });
        }
      } else {
        const jobSeekerProfile = await ctx.db.get(args.targetId);
        if (!jobSeekerProfile) throw new Error("Job seeker profile not found");

        // Check if job seeker has already swiped right on this job
        const jobSeekerSwipe = await ctx.db
          .query("swipes")
          .withIndex("by_userId_and_targetId", (q) =>
            q.eq("userId", jobSeekerProfile.userId).eq("targetId", user._id)
          )
          .first();

        if (jobSeekerSwipe?.direction === "right") {
          // Create match
          await ctx.db.insert("matches", {
            jobSeekerId: jobSeekerProfile.userId,
            recruiterId: user._id,
            jobPostId: args.targetId,
            matchReport: "", // Will be generated by AI
            status: "new",
            createdAt: Date.now(),
            updatedAt: Date.now(),
          });
        }
      }
    }

    return swipeId;
  },
});

export const getMatches = query({
  args: {},
  async handler(ctx) {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthenticated");

    const user = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", identity.email))
      .first();

    if (!user) throw new Error("User not found");

    if (user.role === "job-seeker") {
      return await ctx.db
        .query("matches")
        .withIndex("by_jobSeekerId", (q) => q.eq("jobSeekerId", user._id))
        .collect();
    } else {
      return await ctx.db
        .query("matches")
        .withIndex("by_recruiterId", (q) => q.eq("recruiterId", user._id))
        .collect();
    }
  },
});

export const updateMatchStatus = mutation({
  args: {
    matchId: v.id("matches"),
    status: v.string(),
  },
  async handler(ctx, args) {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthenticated");

    const user = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", identity.email))
      .first();

    const match = await ctx.db.get(args.matchId);
    throwIfNotAuthorized(
      match?.jobSeekerId === user?._id || match?.recruiterId === user?._id,
      "Not authorized to update this match"
    );

    await ctx.db.patch(args.matchId, {
      status: args.status,
      updatedAt: Date.now(),
    });
  },
});